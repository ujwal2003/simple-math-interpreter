Infix_Nodes_List:
	let there be a list of nodes
	let a 'previous token' variable be initialized to none
	
	while there are tokens to be read:
		if the token is either: number, var, *, /, (, or ) :
			create appropriate node and append it to back of the list
			set the previous token to the current token
			advance to the next token
		
		if the token is either + or - and the previous token is either a +, - or none:
			do Create_Unary_Operator_Node() and append the returned node to back of the list
			
	return the list
			
			
Create_Unary_Operator_Node:
	if the current token is a plus:
		advance to the next token
		return a unary operator node => ("+", recursive: Create_Unary_Operator_Node())
		
	else if the current token is a minus:
		advance to the next token
		return a unary operator node => ("-", recursive: Create_Unary_Operator_Node())
		
	else if the current token is an atom (a.k.a number or variable):
		return an atom() node
		
	else:
		raise an invalid syntax error
		

Shunting_Yard_Algorithm(input->list of nodes):
	let there be a queue of nodes known as the 'output queue'
	let there be a stack of nodes known as the 'operator stack'
	
	for each node in the list:
		if the node is a number, variable or unary-operator:
			push it into the output queue
			
		else if the node is in {+-*/} and the operator stack is empty:
			push it into the operator stack
			
		else if the node is in {+-*/} and the operator stack is not empty:
			while (the stack isn't empty) and the top of the operator stack is not a open parenthesis and 
			  either (the top has greater precedence than the node 
			  or the node and the top have the same precedence and the node is left associative):
					pop the top of the operator stack and push it into the output queue
			push the node into the operator stack
			
		else if the node is an open parenthesis:
			push it into the operator stack
			
		else if the node is a closed parenthesis:
			while the stack is not empty and the top is not an open parenthesis:
				pop the top of the operator stack and push it into the output queue
				
			if the stack is not empty and the top of the stack is an open parenthesis:
				pop the top of the operator stack
			else:
				raise a mismatched parenthesis error
				
			if the stack is not empty and is an operator:
				pop the top of the operator stack and push it into the output queue
				
	while the stack is not empty:
		if the top of the stack is a parenthesis:
			raise a mismatched parenthesis error
		pop the top of the operator stack and push it into the output queue
		
	return the output queue
			
			
expression_AST:
	let there be a list of nodes called 'infix' = Infix_Nodes_List()
	let there be a queue of nodes called 'postfix' = Shunting_Yard_Algorithm(infix)
	
	let there be a stack of nodes called 'AST_stack'
	
	while postfix is not empty:
		if the front of postfix is either a unary-operator, a number, or a variable:
			push it onto the AST_stack
			pop the front of postfix
			
		else if the front of postfix is in {+-*/}:
			if the stack has at least a size of two:
				pop the top of the stack and add it as the right node of the front of postfix
				pop the top of the stack and add it as the left node of the front of postfix
				push the front of postfix onto the stack
				pop the front of postfix
			else:
				raise an invalid syntax error for the current node
				
		else:
			raise an error
			
	if the stack has a size greater than one:
		raise an error
	else:
		return the top of the stack